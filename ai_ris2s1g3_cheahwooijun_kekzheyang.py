# -*- coding: utf-8 -*-
"""AI_RIS2S1G3_CHEAHWOOIJUN_KEKZHEYANG.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R2O5ujMSQUzw13LxybT4-Y4ICtWgt2OP
"""

# Cell 1: Imports & environment detection
import sys
IN_COLAB = 'google.colab' in sys.modules

import pandas as pd
import numpy as np
import ast
import random
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import linear_kernel, cosine_similarity
from sklearn.metrics import mean_squared_error
import requests
from io import StringIO
import matplotlib.pyplot as plt
import seaborn as sns

if IN_COLAB:
    !pip install -q gradio
    import gradio as gr
else:
    import streamlit as st

# Cell 2: Helper display functions
def show_df(df, title=""):
    if IN_COLAB:
        print(title)
        display(df)
    else:
        st.write(f"### {title}")
        st.dataframe(df)

def show_plot(fig):
    if IN_COLAB:
        plt.show(fig)
    else:
        st.pyplot(fig)

# Cell 3: Load datasets
MOVIES_URL = "https://drive.google.com/uc?export=download&id=1GOuUEu1-KgepbjTxIOkbAU8VNJ5lfEg3"
CREDITS_URL = "https://drive.google.com/uc?export=download&id=10iuK9C87fYLyDLJhqT3bpVv1A2IErmHR"
RATINGS_URL = "https://drive.google.com/uc?export=download&id=122XJoryYXvv3AUa6F_y1KiCcYdXQjEp4"

def load_data_from_url(url):
    response = requests.get(url)
    response.raise_for_status()
    return pd.read_csv(StringIO(response.text))

def load_data():
    movies = load_data_from_url(MOVIES_URL)
    credits = load_data_from_url(CREDITS_URL)
    ratings = load_data_from_url(RATINGS_URL)

    movies = movies[movies['vote_count'] > 500]
    movies['id'] = pd.to_numeric(movies['id'], errors='coerce')
    credits['id'] = pd.to_numeric(credits['id'], errors='coerce')
    ratings['movieId'] = pd.to_numeric(ratings['movieId'], errors='coerce')
    movies = movies.dropna(subset=['id'])
    credits = credits.dropna(subset=['id'])
    ratings = ratings.dropna(subset=['movieId'])
    movies['id'] = movies['id'].astype(int)
    credits['id'] = credits['id'].astype(int)
    ratings['movieId'] = ratings['movieId'].astype(int)

    movies = movies.merge(credits, on='id', how='inner')
    movies['overview'] = movies['overview'].fillna('')
    movies['tagline'] = movies['tagline'].fillna('')
    movies['description'] = movies['overview'] + " " + movies['tagline']
    movies = movies[['id', 'title', 'description', 'genres', 'cast', 'crew']]

    # Parsing features
    def parse_genres(obj):
        try: return [i['name'] for i in ast.literal_eval(obj)]
        except: return []
    def parse_cast(obj):
        try: return [i['name'] for i in ast.literal_eval(obj)[:3]]
        except: return []
    def parse_crew(obj):
        try: return [i['name'] for i in ast.literal_eval(obj) if i['job']=='Director']
        except: return []

    movies['genres'] = movies['genres'].apply(parse_genres).apply(lambda x: " ".join(x))
    movies['cast'] = movies['cast'].apply(parse_cast).apply(lambda x: " ".join(x))
    movies['crew'] = movies['crew'].apply(parse_crew).apply(lambda x: " ".join(x))
    movies['final_features'] = movies['description'] + ' ' + movies['genres'] + ' ' + movies['cast'] + ' ' + movies['crew']

    return movies, ratings

# Cell 4: TF-IDF and collaborative models
def create_tfidf_model(movies):
    tfidf = TfidfVectorizer(stop_words='english', max_features=5000)
    vectors = tfidf.fit_transform(movies['final_features'])
    return tfidf, vectors

def prepare_collaborative_data(movies, ratings):
    movies_cf = movies[['id','title']].rename(columns={'id':'movieId'})
    ratings = ratings.merge(movies_cf, on="movieId", how="inner")

    user_mapping = {1:"Bob",2:"Alice",3:"Charlie",4:"Diana",5:"Eve"}
    ratings['user_name'] = ratings['userId'].replace(user_mapping)
    user_item_matrix = ratings.pivot_table(index='user_name', columns='title', values='rating').fillna(0)
    user_sim = cosine_similarity(user_item_matrix)
    user_sim_df = pd.DataFrame(user_sim, index=user_item_matrix.index, columns=user_item_matrix.index)
    return ratings, user_item_matrix, user_sim_df

# Cell 5: Recommendation algorithms
def content_based_recommend(movie_title, movies, vectors, top_n=10):
    if movie_title not in movies['title'].values: return "❌ Movie not found", []
    idx = movies[movies['title']==movie_title].index[0]
    cosine_scores = linear_kernel(vectors[idx], vectors).flatten()
    similar_indices = cosine_scores.argsort()[-(top_n+1):-1][::-1]
    recs = movies.iloc[similar_indices].title.tolist()
    scores = cosine_scores[similar_indices].tolist()
    return "Content-based recommendations", [(t,float(s)) for t,s in zip(recs,scores)]

def collaborative_recommend(user_name, user_item_matrix, user_sim_df, top_n=50):
    if user_name not in user_item_matrix.index: return {}
    sim_scores = user_sim_df[user_name].drop(user_name).sort_values(ascending=False)
    top_users = sim_scores.index[:5]
    neighbor_ratings = user_item_matrix.loc[top_users].mean(axis=0)
    watched = user_item_matrix.loc[user_name][user_item_matrix.loc[user_name]>0].index
    neighbor_ratings = neighbor_ratings.drop(watched, errors='ignore')
    top_recs = neighbor_ratings.sort_values(ascending=False).head(top_n)
    return {t:score for t,score in top_recs.items()}

def hybrid_recommend(user_name, liked_movie, movies, vectors, user_item_matrix, user_sim_df, alpha=0.5, top_n=10):
    if not user_name or user_name.strip()=="" or user_name=="-":
        user_name = f"User_{random.randint(6,671)}"
    collab_scores = collaborative_recommend(user_name,user_item_matrix,user_sim_df,top_n=50)
    if liked_movie not in movies['title'].values: return user_name,[("❌ Movie not found",0.0)]
    idx = movies.index[movies['title']==liked_movie][0]
    cs = linear_kernel(vectors[idx], vectors).flatten()
    content_scores = {movies.iloc[i].title:float(cs[i]) for i in cs.argsort()[-51:-1]}
    all_titles = set(collab_scores.keys())|set(content_scores.keys())
    hybrid_scores = {t: alpha*content_scores.get(t,0.0)+(1-alpha)*collab_scores.get(t,0.0) for t in all_titles}
    ranked = sorted(hybrid_scores.items(), key=lambda x:x[1], reverse=True)[:top_n]
    return user_name, [(t,float(s)) for t,s in ranked]

# Cell 6: Evaluation helpers
def build_eval_helpers(movies, ratings, vectors):
    content_similarity = linear_kernel(vectors,vectors)
    ratings_agg = ratings.groupby(['userId','movieId'])['rating'].mean().reset_index()
    ratings_matrix = ratings_agg.pivot(index="userId",columns="movieId",values="rating").fillna(0)
    user_sim = cosine_similarity(ratings_matrix)
    user_sim_df = pd.DataFrame(user_sim, index=ratings_matrix.index, columns=ratings_matrix.index)

    def content_predict(user_id,movie_id):
        if movie_id not in movies['id'].values: return None
        idx = movies[movies['id']==movie_id].index[0]
        sims = content_similarity[idx]
        user_ratings = ratings[ratings['userId']==user_id]
        if user_ratings.empty: return None
        sim_scores = [(row['rating'],sims[movies[movies['id']==row['movieId']].index[0]])
                      for _,row in user_ratings.iterrows() if row['movieId'] in movies['id'].values]
        if not sim_scores: return None
        weighted_sum = sum(r*s for r,s in sim_scores)
        sim_sum = sum(s for _,s in sim_scores)
        return weighted_sum/sim_sum if sim_sum!=0 else None

    def collab_predict(user_id,movie_id):
        if movie_id not in ratings_matrix.columns: return None
        if user_id not in user_sim_df.index: return None
        sims = user_sim_df[user_id].drop(user_id,errors='ignore')
        top_users = sims.sort_values(ascending=False).head(5).index
        if top_users.empty: return None
        top_ratings = ratings_matrix.loc[top_users, movie_id]
        weights = sims.loc[top_users]
        if weights.sum()==0: return None
        return np.dot(top_ratings,weights)/weights.sum()

    def hybrid_predict(user_id,movie_id,alpha=0.5):
        cp = content_predict(user_id,movie_id)
        cf = collab_predict(user_id,movie_id)
        if cp is None and cf is None: return None
        if cp is None: return cf
        if cf is None: return cp
        return alpha*cp+(1-alpha)*cf

    return content_predict, collab_predict, hybrid_predict, ratings_agg

def evaluate_model(predict_func, ratings_agg, n_samples=300):
    test = ratings_agg.sample(n_samples, random_state=42)
    preds, truths = [],[]
    for _, row in test.iterrows():
        pred = predict_func(row['userId'],row['movieId'])
        if pred is not None:
            preds.append(pred)
            truths.append(row['rating'])
    if not preds: return None,None
    mse = mean_squared_error(truths,preds)
    rmse = np.sqrt(mse)
    return mse, rmse

# Cell 7: Main function with fixed Streamlit dropdowns
movies, ratings = load_data()
tfidf, vectors = create_tfidf_model(movies)
ratings, user_item_matrix, user_sim_df = prepare_collaborative_data(movies, ratings)
content_predict, collab_predict, hybrid_predict, ratings_agg = build_eval_helpers(movies, ratings, vectors)

# Unified function for UI
def get_recommendations_ui(movie_title, rec_type="Content-Based", user_name="-", num_recs=10):
    if rec_type=="Content-Based":
        method_name, recs = content_based_recommend(movie_title, movies, vectors, top_n=num_recs)
    else:
        resolved_user, recs = hybrid_recommend(
            user_name, movie_title, movies, vectors, user_item_matrix, user_sim_df, top_n=num_recs
        )
        method_name = f"Hybrid Recommendations for {resolved_user}"
    max_score = max([s for _,s in recs]) if recs else 1.0
    rec_list = [(t, (s/max_score)*100) for t,s in recs]
    return rec_list

if IN_COLAB:
    # Colab → Gradio UI
    demo = gr.Interface(
        fn=get_recommendations_ui,
        inputs=[
            gr.Textbox(label="Movie Title"),
            gr.Radio(["Content-Based","Hybrid"], label="Recommendation Type"),
            gr.Textbox(label="User Name (for Hybrid)"),
            gr.Slider(1,20,10,label="Number of Recommendations")
        ],
        outputs=gr.Dataframe(headers=["Movie","Score (%)"])
    )
    demo.launch()
else:
    # Streamlit → Dropdowns and slider
    st.title("🎬 Movie Recommender System")
    
    rec_type = st.radio("Recommendation Type", ["Content-Based","Hybrid"])
    
    # User dropdown for Hybrid
    user_choices = ["-","Bob","Alice","Charlie","Diana","Eve"]
    user_choice = st.selectbox("Select User", user_choices) if rec_type=="Hybrid" else "-"
    
    # Movie dropdown
    movie_title = st.selectbox("Select a Movie", sorted(movies['title'].unique()))
    
    # Number of recommendations
    num_recs = st.slider("Number of Recommendations",1,20,10)

    if st.button("Get Recommendations"):
        rec_list = get_recommendations_ui(movie_title, rec_type, user_choice, num_recs)
        rec_df = pd.DataFrame(rec_list, columns=["Movie","Score (%)"])
        st.table(rec_df)

        # Evaluation Section
        st.subheader("📊 Evaluation Section")
        eval_df = pd.DataFrame({
            "System":["Content-Based","Collaborative","Hybrid"],
            "MSE":[evaluate_model(content_predict, ratings_agg)[0],
                   evaluate_model(collab_predict, ratings_agg)[0],
                   evaluate_model(hybrid_predict, ratings_agg)[0]],
            "RMSE":[evaluate_model(content_predict, ratings_agg)[1],
                    evaluate_model(collab_predict, ratings_agg)[1],
                    evaluate_model(hybrid_predict, ratings_agg)[1]]
        })
        st.table(eval_df)
        fig, ax = plt.subplots(figsize=(8,4))
        sns.barplot(x="System",y="RMSE",data=eval_df,palette="viridis", ax=ax)
        ax.set_title("RMSE Comparison (Lower is Better)")
        st.pyplot(fig)
